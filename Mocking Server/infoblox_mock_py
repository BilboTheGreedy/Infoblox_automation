from flask import Flask, request, jsonify, abort
import json
import ipaddress
import re
import uuid
from datetime import datetime
import logging

app = Flask(__name__)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# In-memory database to store our objects
db = {
    "network": [],
    "network_container": [],
    "record:host": [],
    "record:a": [],
    "record:ptr": [],
    "range": [],
    "lease": [],
    "fixedaddress": []
}

# Initialize with some default data
def initialize_db():
    # Add a network container
    db["network_container"].append({
        "_ref": f"networkcontainer/ZG5zLm5ldHdvcmtfY29udGFpbmVyJDEwLjAuMC4wLzg:10.0.0.0/8",
        "network": "10.0.0.0/8",
        "network_view": "default",
        "comment": "Default network container",
        "extattrs": {}
    })
    
    # Add a network
    db["network"].append({
        "_ref": f"network/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:10.10.10.0/24",
        "network": "10.10.10.0/24",
        "network_view": "default",
        "comment": "Development network",
        "extattrs": {}
    })
    
    # Add a DHCP range
    db["range"].append({
        "_ref": f"range/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:10.10.10.100-10.10.10.200",
        "network": "10.10.10.0/24",
        "network_view": "default",
        "start_addr": "10.10.10.100",
        "end_addr": "10.10.10.200",
        "comment": "DHCP range for development",
        "extattrs": {}
    })
    
    # Add a host record
    db["record:host"].append({
        "_ref": f"record:host/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:server1.example.com",
        "name": "server1.example.com",
        "view": "default",
        "ipv4addrs": [{"ipv4addr": "10.10.10.5"}],
        "comment": "Application server",
        "extattrs": {}
    })
    
    # Add an A record
    db["record:a"].append({
        "_ref": f"record:a/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:www.example.com",
        "name": "www.example.com",
        "view": "default",
        "ipv4addr": "10.10.10.6",
        "comment": "Web server",
        "extattrs": {}
    })

# Initialize the database
initialize_db()

# Helper functions
def generate_ref(obj_type, obj_data):
    """Create a reference ID similar to what Infoblox generates"""
    if obj_type == "network" or obj_type == "network_container":
        network = obj_data.get("network")
        encoded = str(uuid.uuid4()).replace("-", "")[:24]
        return f"{obj_type}/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:{network}"
    elif obj_type == "range":
        start = obj_data.get("start_addr")
        end = obj_data.get("end_addr")
        encoded = str(uuid.uuid4()).replace("-", "")[:24]
        return f"{obj_type}/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:{start}-{end}"
    elif obj_type.startswith("record:"):
        name = obj_data.get("name")
        encoded = str(uuid.uuid4()).replace("-", "")[:24]
        return f"{obj_type}/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:{name}"
    elif obj_type == "lease" or obj_type == "fixedaddress":
        ip = obj_data.get("ipv4addr") or obj_data.get("ip_address")
        encoded = str(uuid.uuid4()).replace("-", "")[:24]
        return f"{obj_type}/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:{ip}"
    else:
        return f"{obj_type}/{str(uuid.uuid4())}"

def find_object_by_ref(ref):
    """Find an object by its reference ID"""
    obj_type = ref.split('/')[0]
    if obj_type not in db:
        return None
    
    for obj in db[obj_type]:
        if obj["_ref"] == ref:
            return obj
    return None

def find_objects_by_query(obj_type, query_params):
    """Find objects matching query parameters"""
    results = []
    
    if obj_type not in db:
        return results
    
    for obj in db[obj_type]:
        match = True
        for key, value in query_params.items():
            # Handle nested attributes with '.'
            if '.' in key:
                parts = key.split('.')
                curr = obj
                for part in parts[:-1]:
                    if part in curr:
                        curr = curr[part]
                    else:
                        match = False
                        break
                if match and (parts[-1] not in curr or curr[parts[-1]] != value):
                    match = False
            # Handle special case for ipv4addrs which is a list
            elif key == "ipv4addrs":
                # This is a simplification - in real Infoblox you'd need more complex matching
                if not any(addr["ipv4addr"] == value for addr in obj.get("ipv4addrs", [])):
                    match = False
            # Regular attribute
            elif key not in obj or obj[key] != value:
                match = False
        
        if match:
            results.append(obj)
    
    return results

# Routes to mimic Infoblox WAPI
@app.route('/wapi/v2.11/<obj_type>', methods=['GET', 'POST'])
def handle_objects(obj_type):
    # Handle GET (search)
    if request.method == 'GET':
        query_params = request.args.to_dict()
        results = find_objects_by_query(obj_type, query_params)
        
        # Handle _return_fields
        if '_return_fields' in query_params:
            fields = query_params['_return_fields'].split(',')
            filtered_results = []
            for result in results:
                filtered_result = {"_ref": result["_ref"]}  # _ref is always included
                for field in fields:
                    if field in result:
                        filtered_result[field] = result[field]
                filtered_results.append(filtered_result)
            results = filtered_results
        
        return jsonify(results)
    
    # Handle POST (create)
    elif request.method == 'POST':
        data = request.json
        
        # Validate data based on object type
        if obj_type == "network":
            if "network" not in data:
                abort(400, description="Missing required field 'network'")
            try:
                ipaddress.ip_network(data["network"])
            except ValueError:
                abort(400, description="Invalid network format")
        
        elif obj_type == "record:host":
            if "name" not in data or "ipv4addrs" not in data:
                abort(400, description="Missing required fields")
            
            # Validate hostname
            if not re.match(r'^[a-zA-Z0-9.-]+$', data["name"]):
                abort(400, description="Invalid hostname format")
            
            # Validate IP addresses
            for addr in data["ipv4addrs"]:
                if "ipv4addr" not in addr:
                    abort(400, description="Missing ipv4addr in ipv4addrs")
                try:
                    ipaddress.ip_address(addr["ipv4addr"])
                except ValueError:
                    abort(400, description="Invalid IP address format")
        
        # Set default values
        if "network_view" not in data and obj_type in ["network", "network_container"]:
            data["network_view"] = "default"
        
        if "view" not in data and obj_type.startswith("record:"):
            data["view"] = "default"
        
        # Create the object reference
        data["_ref"] = generate_ref(obj_type, data)
        
        # Add timestamp
        data["_create_time"] = datetime.now().isoformat()
        data["_modify_time"] = data["_create_time"]
        
        # Save to database
        if obj_type not in db:
            db[obj_type] = []
        db[obj_type].append(data)
        
        # Return reference as per Infoblox API
        return jsonify(data["_ref"])

@app.route('/wapi/v2.11/<path:ref>', methods=['GET', 'PUT', 'DELETE'])
def handle_object(ref):
    # Extract object type from reference
    obj_type = ref.split('/')[0]
    
    # Handle GET (read)
    if request.method == 'GET':
        obj = find_object_by_ref(ref)
        if not obj:
            abort(404, description="Object not found")
        
        # Handle _return_fields
        if '_return_fields' in request.args:
            fields = request.args['_return_fields'].split(',')
            filtered_obj = {"_ref": obj["_ref"]}  # _ref is always included
            for field in fields:
                if field in obj:
                    filtered_obj[field] = obj[field]
            return jsonify(filtered_obj)
        
        return jsonify(obj)
    
    # Handle PUT (update)
    elif request.method == 'PUT':
        obj = find_object_by_ref(ref)
        if not obj:
            abort(404, description="Object not found")
        
        data = request.json
        # Update object with new data
        for key, value in data.items():
            # Skip reserved fields
            if key.startswith('_'):
                continue
            obj[key] = value
        
        # Update timestamp
        obj["_modify_time"] = datetime.now().isoformat()
        
        return jsonify(ref)
    
    # Handle DELETE
    elif request.method == 'DELETE':
        obj = find_object_by_ref(ref)
        if not obj:
            abort(404, description="Object not found")
        
        # Remove object from database
        db[obj_type] = [o for o in db[obj_type] if o["_ref"] != ref]
        
        return jsonify(ref)

# Functions for grid operations
@app.route('/wapi/v2.11/grid', methods=['GET'])
def get_grid():
    return jsonify([{
        "_ref": "grid/1",
        "name": "Infoblox Grid",
        "version": "NIOS 8.6.0",
        "status": "ONLINE"
    }])

@app.route('/wapi/v2.11/grid/1', methods=['GET'])
def get_grid_info():
    return jsonify({
        "_ref": "grid/1",
        "name": "Infoblox Grid",
        "version": "NIOS 8.6.0",
        "status": "ONLINE",
        "license_type": "ENTERPRISE",
        "allow_recursive_deletion": True,
        "support_email": "support@example.com",
        "restart_status": {
            "restart_required": False
        }
    })

# Grid member operations
@app.route('/wapi/v2.11/member', methods=['GET'])
def get_members():
    return jsonify([{
        "_ref": "member/1",
        "host_name": "infoblox.example.com",
        "config_addr_type": "IPV4",
        "platform": "PHYSICAL",
        "service_status": "WORKING",
        "node_status": "ONLINE"
    }])

# Function for next available IP
@app.route('/wapi/v2.11/network/<path:network>/next_available_ip', methods=['POST'])
def next_available_ip(network):
    network_ref = f"network/ZG5zLm5ldHdvcmskMTAuMTAuMTAuMC8yNA:{network}"
    
    # Find network
    network_obj = None
    for net in db["network"]:
        if net["_ref"] == network_ref or net["network"] == network:
            network_obj = net
            break
    
    if not network_obj:
        abort(404, description="Network not found")
    
    # Parse network to generate next IP
    try:
        net = ipaddress.ip_network(network_obj["network"])
        
        # Find used IPs
        used_ips = set()
        for obj_type in ["record:host", "record:a", "fixedaddress", "lease"]:
            for obj in db.get(obj_type, []):
                if obj_type == "record:host":
                    for addr in obj.get("ipv4addrs", []):
                        used_ips.add(addr["ipv4addr"])
                elif obj_type == "record:a":
                    used_ips.add(obj.get("ipv4addr", ""))
                else:
                    used_ips.add(obj.get("ipv4addr", ""))
        
        # Find next available IP
        for ip in net.hosts():
            ip_str = str(ip)
            if ip_str not in used_ips:
                # Skip network address, broadcast address, and gateway
                if ip == net.network_address or ip == net.broadcast_address or ip_str.endswith(".1"):
                    continue
                return jsonify({"ips": [ip_str]})
        
        # No available IPs
        abort(400, description="No available IPs in network")
    except Exception as e:
        abort(400, description=str(e))

# Function for search by CIDR
@app.route('/wapi/v2.11/ipv4address', methods=['GET'])
def search_ipv4address():
    ip_addr = request.args.get('ip_address')
    network = request.args.get('network')
    
    if not ip_addr and not network:
        abort(400, description="Missing required parameters")
    
    results = []
    
    if ip_addr:
        # Find all objects with this IP
        for obj_type in ["record:host", "record:a", "fixedaddress", "lease"]:
            for obj in db.get(obj_type, []):
                if obj_type == "record:host":
                    if any(addr["ipv4addr"] == ip_addr for addr in obj.get("ipv4addrs", [])):
                        results.append({
                            "objects": [obj["_ref"]],
                            "ip_address": ip_addr,
                            "status": "USED",
                            "names": [obj["name"]],
                            "types": [obj_type]
                        })
                elif obj_type == "record:a" and obj.get("ipv4addr") == ip_addr:
                    results.append({
                        "objects": [obj["_ref"]],
                        "ip_address": ip_addr,
                        "status": "USED",
                        "names": [obj["name"]],
                        "types": [obj_type]
                    })
                elif obj.get("ipv4addr") == ip_addr:
                    results.append({
                        "objects": [obj["_ref"]],
                        "ip_address": ip_addr,
                        "status": "USED",
                        "types": [obj_type]
                    })
    
    if network:
        # Find all networks and IPs in the CIDR
        try:
            net = ipaddress.ip_network(network)
            
            # Check if we have network objects for this network
            for net_obj in db.get("network", []):
                if ipaddress.ip_network(net_obj["network"]).overlaps(net):
                    results.append({
                        "objects": [net_obj["_ref"]],
                        "network": net_obj["network"],
                        "status": "USED",
                        "types": ["network"]
                    })
            
            # Check for IPs in this network
            for obj_type in ["record:host", "record:a", "fixedaddress", "lease"]:
                for obj in db.get(obj_type, []):
                    ips = []
                    if obj_type == "record:host":
                        ips = [addr["ipv4addr"] for addr in obj.get("ipv4addrs", [])]
                    elif obj_type == "record:a":
                        ips = [obj.get("ipv4addr", "")]
                    else:
                        ips = [obj.get("ipv4addr", "")]
                    
                    for ip in ips:
                        try:
                            if ip and ipaddress.ip_address(ip) in net:
                                result = {
                                    "objects": [obj["_ref"]],
                                    "ip_address": ip,
                                    "status": "USED",
                                    "types": [obj_type]
                                }
                                if obj_type in ["record:host", "record:a"] and "name" in obj:
                                    result["names"] = [obj["name"]]
                                results.append(result)
                        except:
                            pass
        except Exception as e:
            abort(400, description=str(e))
    
    # If no results, add UNUSED status
    if not results and ip_addr:
        results.append({
            "ip_address": ip_addr,
            "status": "UNUSED",
            "types": []
        })
    
    return jsonify(results)

# Authentication endpoint (basic simulation)
@app.route('/wapi/v2.11/grid/session', methods=['POST', 'DELETE'])
def handle_session():
    if request.method == 'POST':
        return jsonify({"username": "admin"})
    else:  # DELETE
        return "", 204

if __name__ == '__main__':
    app.run(debug=True, port=8080)